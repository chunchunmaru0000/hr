#######################################################################################
# 								COMPILER
#######################################################################################
args to compiler

#######################################################################################
# 								ENUM
#######################################################################################
UNREPEATABLE flag for an enum

#######################################################################################
# 								ASM
#######################################################################################
let a, b, c, d byte "hello world"
so plist of names in let statement of the assembly

#######################################################################################
# 								ARGS
#######################################################################################
do ',' fun arg types like the ones that are possible in function signature but
function variable signature

*ч32 == *[ч32], so arr type is equal to just the type, array only haves size
#######################################################################################
# 								COMMENTS
#######################################################################################
source code comments in assembly, need to get the last token of an instruction also

#######################################################################################
# 								ATOMAR THINGS
#######################################################################################
атом ( ... )

#######################################################################################
# 								UNDEF
#######################################################################################
when i will have defns as a dictionary then i can do maybe #undef

#######################################################################################
# 								OPTIMIZATIONS
#######################################################################################
Constant folding
Constant propagation like for local variable have bool where if its not changed from
	last constant value then it can take it
not gonna do Dead code elimination cuz useless in 'implicit language'
Register allocation with как рег expression, u need to alloc reristers urlesf

#######################################################################################
# 								PREPROCESSOR
#######################################################################################
#буки (# целых #~1 число# раз#|раза ведать #слова# . #) (##)

defined number of tokens in argument, such argument may be not separated by
other tokens

#######################################################################################
# 								AS IN LOOP
#######################################################################################
как register expression in loop defenition
для с как рсх от 0 до 10 ( ... )

#######################################################################################
# 								SYNTAX IDEAS
#######################################################################################
// Rust while let
while let Some(x) = stack.pop() {
    ...
}
// Guard Clauses
function x y
  | x > 0     = ...
  | otherwise = ...

defer

let for match
switch (opt) {
    case let .type == OPT_INT, .value as val:
        use(val);
        break;
    case let .type == OPT_STR, .str as s:
        use_str(s);
        break;
}

ZIG
// Вместо:
if (open_file() == NULL) return -1;
if (read_file() < 0) return -1;
// Могло бы быть:
try open_file() else return -1;
try read_file() else return -1;
// Или даже:
result = open_file() catch { return -1 };

#######################################################################################
# 			INLINE MACRO OR ANONIMOUS FUNS
#######################################################################################
пусть ( а: ч32 )
а =
    2
    |> фц ( х: ч32 ) ч32 ( х * х )
    |> фц ( х: ч32 ) ч32 ( х + х )

пусть ( ф: (ч32 ч32) )
ф = фц ( х: ч32 ) ч32 (
    ; вот тут уже между анонимными функциями и основной функции должны
    ; тоже быть области видимости
    пусть ( у: ч32 )
    у = х
    х = 123
    х += у * у
)
