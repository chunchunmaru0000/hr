#######################################################################################
# 								COMPILER
#######################################################################################
args to compiler

#######################################################################################
# 								ENUM
#######################################################################################
UNREPEATABLE flag for an enum

#######################################################################################
# 								ASM
#######################################################################################
let a, b, c, d byte "hello world"
so plist of names in let statement of the assembly

#######################################################################################
# 								ARGS
#######################################################################################
do ',' fun arg types like the ones that are possible in function signature but
function variable signature

*ч32 == *[ч32], so arr type is equal to just the type, array only haves size
#######################################################################################
# 								COMMENTS
#######################################################################################
source code comments in assembly, need to get the last token of an instruction also

#######################################################################################
# 								ATOMAR THINGS
#######################################################################################
атом ( ... )

#######################################################################################
# 								UNDEF
#######################################################################################
when i will have defns as a dictionary then i can do maybe #undef

#######################################################################################
# 								PIPELINE
#######################################################################################
pipeline operator with tuple expressions, tuples are just bunch of args, its just some
abstract value, not like struct or array
() |> f
(a,) |> f
(a, b) |> f

value |> f

or just with single value

f a, b,
a, |> f

#######################################################################################
# 								#+, #" "#
#######################################################################################
1 #+ 2 вернет токен 12, токены подставляются примененные а не текстовые
#" превращает все что в них в строку, токены берутся текстовые "#

#######################################################################################
# 								SENTENCE
#######################################################################################
Это не макро, это сказ или предложение, его именем являются все его токены до момента
первого аргумента, и его вызов завершается запятой, если последний его токен это аргумент
Знак #| означает что токеном может быть любой из окружающих этот знак он типа как || (или)

#сказ (#
    вот #переменная# будет#|станет вообще типа #тип# и значением #значение#
#) (#
	пусть переменная: тип = значение
#)

вот _1 будет вообще типа ц8 и значением 123 + 123,
вот _2 станет вообще типа ц8 и значением 123 + 123,


#сказ (#
	каждый #шт# по #штук# (
;; ну тут типа по факту нет смысла в #...# ведь можно просто
   с ожной стороны сдлать сказ а с другой скобкой закрывать
   сказ же тоже может просто на кобку кончаться
		#...#
	)
;;
#) (#
	для с на 0..штук->длиной (
;;
		#...#
	)
;;
#)

#######################################################################################
# 			INLINE MACRO OR ANONIMOUS FUNS
#######################################################################################
пусть ( а: ч32 )
а =
    2
    |> фц ( х: ч32 ) ч32 ( х * х )
    |> фц ( х: ч32 ) ч32 ( х + х )

пусть ( ф: (ч32 ч32) )
ф = фц ( х: ч32 ) ч32 (
    ; вот тут уже между анонимными функциями и основной функции должны
    ; тоже быть области видимости
    пусть ( у: ч32 )
    у = х
    х = 123
    х += у * у
)
