## Области видимости

Их нет, кроме как между функциями.

## Влечь

влечь "ввывд"

## Вот

вот имя выражение
вот чето 1 + 3 + 4 + 5

## Встроенные типы

ч - число
ц - целое
в - вещественное

ч8			int8, byte
ч16			int16
ч32			int32
ч64			int64
ц8			uint8
ц16			uint16
ц32			uint32
ц64			uint64
в32			float, single
в64			double, real
тлен		void
*			*
*тлен		void *
стр *ц8		unsigned char *
**ч32		int **
лик _		struct _ *
лик Чето	struct Some *	; ображение к лику не по указателю все равно не поддерживается
счет		enum
счет Чето	enum Some
[ч32]		int[]
[[ц64]]		uint64[][]
[ч32 123]	int[123]
[[ц64 3] 4]	uint64[4][3]
(ч32 ч32 ! ч32) 			int(*f)(int, int) ; это в любом случае указатель
[(ч32 ч32 ! ч32) 2] 		int (*op[2])(int, int)
(тлен)						void(*f)()


## Знаки

+			+
-			-
*			*
/			/
* 			*
& 			&
()			()
->			->
[]			[]

## Счет

счет ЧЕТО(
	А ; 1
	Б ; 2
	В
	Г
	Д 7 ; 7
	Ж ; 5
	З ; 6
)
ЧЕТО.А
ЧЕТО.Б
ЧЕТО.З

## Лик

лик Чето(
	а : ч32
	йцук/б : ц64
)

## break continue

отсутствуют

## label, goto или метка, идти

asdf:
goto adsf;

йцук:
идти йцук

Используются вместо break и continue, так как они считаются избыточными
и усложнающими реализацию циклов для компилятора.
На них также распространяются области видимостей функций, в ассемблере к каждой
метке добавляется сигнатура функции.
;;
	может быть сделать глобальные метки, чтобы а вот чебы нет
;;

## Циклы

while(1) { ... }
вечно ( ... ) ; в ассемблере оно вообще освобождено от проверки в данном случае

while(expr) { ... }
пока выражение ( ... )

for (с = 0; с < 10; с++) { ... }
для с на 0..10 <шаг 1> ( ... )
for (с = 0; с <= 10; с++) { ... }
для с на 0..=10 <шаг 1> ( ... )
for (с = 10; с >= 0; с--) { ... }
для с на 10..=0 <шаг -1> ( ... )

for (set; expr; change) { ... }
цикл set, expr, change ( ... )

## if else

если выражение (
) иначели выражение (
) иначели выражение (
) иначели выражение (
) иначе (
)

## switch хотя скорее match

потом короче придумаю но будет отличаться

## Функции

;;
	функция объявляется со слова "фц" и последующим именем функции
	дальше идуд переменные и их типы точно также как и в блоке "пусть"
	после идут скобки с телом функции
;;
фц имя (имя/имя имя :выр_типа имя имя имя имя :выр_типа) выр_типа (
	...
)

фц глав (арги:стр аргов:ч32) (
;;
	каждая функция может иметь объявления перемнных
	они объявляются в блоке пусть, похоже на var в паскале
	но тут меньше символов, также один участок памяти
	может иметь разные имена,
	то есть имен например два, а переменная одна,
	такие имена пишутся через /,
	после перечисления имен через символ : пишется тип переменных

	тип вфункции после первых скобок, если типа нет, то тип становистя тленом
;;
	пусть (
		имя/имя : выр_типа
		имя
		имя
		имя
		:
		 выр_типа
	)
	пусть (
		а/б с д : ч32
		йцук : ч64
		г/д : ц64, е/ж : в64, з : *ч32
;;
	вот здесь переменные объявлены через запятую, но не для разделения объявлений
	а для обозначения того, что они относятся к одному участку памяти, то есть
	не прото "г" и "д" одинаковы и имеют один участок памяти, но и даже "е", "ж" и "з"
	принадлежат к тому же участку памяти, возможно это как минимум потому что они
	одинакового размера: "ц64" и "в64", как и "з" с типом указателя
;;
	)
;;
	переменные могут объявляться только так и
	желательно их объявлять только вначале или почти в начале функции,
	объявление переменных запрещено в блоках если и циклах

	компилятором это не запрещено но будет приводить к лишней трате
	стэка, так как областей видимости, кроме как в функциях в этом
	языке не предусмотрено
;;
)

; функцию можно объявить и без тела, как в С
фц глав ! (арги:стр аргов:ч32) тлен
; или
фц глав ! (:стр :ч32) ч32
; ! перед скобками нужен, если нет объявления имен, а только типов,
; последний ! - закрывающий
## Присваивание

выражение адреса = выражение

пусть ( а : ч32 )
а = 123

### Индексы

пусть ( а : [ч32] с : ч32 )
а[0] = 123
а[с] = 123

## Выражение

### Приведение типа

окак тип_вырж вырж

## Ассемблер

пусть ( а : ч32 )
_асм "
	быть еах 123
	плюс (рбп а), еах
	минс (рбп а) 123
"
