# Язык с минимальным неявным использованием стэка

Правила:
- Стэк используется ТОЛЬКО для стэк фрэйма и хранения на нем локальных переменных функций, и
 сохранения промежуточных при вызове функций значений.
- Функции могут принимать максимум 7 аргументов, все аргументы передаются через регистры
`рси рди р8 р9 р10 р11 р12`.
- Функция использует память только внутри своего стэк фрэйма.
- vararg - запрещен.
- Регистры `р13 р14 р15` сохраняются между вызовами функций через `толк`.
- Выражения(Expression) ограничены в сложности и длине, так как слишком сложные выражения используют стэк
для сохранения промежуточных вычислений, того же самого можно достичь за счет сохранения
промежуточных вычислений в переменные, которые и так на стэке. Это ограничивает пользователя в сложности
выражений но в тоже время не скрывает от него работу с памятью - абсолютно.
- Типизированные регистры доступны в качестве переменных, ради еще большего избежания использования стэка.
- Передача в функции массивов и структур как таковых запрещается, только через указатели.
- Строки и массивы - НЕ УКАЗАТЕЛИ и неявнно не преобразуются, строки - это массивы `ц8`,
массивы это по сути просто ассемблерные метки, от которых идут подряд значения,
указатели - сущности, значениями которых и являются эти метки. Значение массива - все его элементы и его длина
, если явно имеется, значение указателя - просто адрес.
- Индексация разрешена не только по массивам но и по указателям.

# Переменные, аргументы и поля структур

Переменная - один участок памяти,
к которому может быть прявязано множество имен и которые даже могут иметь разные
типы, но при этом одинаковый размер.

Переменные, аргументы функций и поля структур являются одной и той же сущностью,
за исключением того, что аргументы функций не используют различные типы для одного участка памяти,
так как это влияет на сигнатуру функции.

Далее переменая, аргумнент и поле будут взаимозаменяемыми понятиями и иметь возможный синтаксис:

## Синтаксис аргументов

```
имя : тип
имя/имя : тип
имя/имя : тип, имя/имя : тип
имя имя имя/имя имя: тип
```

Знак "," разделяет участок на разные типы.

Знак "/" разделяет участок по разным именам для одного типа.

Таких разделителей может быть сколько угодно. Использование разделителя "/" в аргументах
функций допускается, так как не влияет на сигнатуру функции.

## Про примитивные значения

Обыченое выражение строки, например `"строка"`, возвращает не массив, а указатель, по причине того,
что просто чаще используются строки с указателями, чтобы получить массив со строки, нужно разыменовать ее
обычным для С способом `*"строка"`, и тогда это значение вернет массив `ц8`.

Лики как и строки тоже по укмолчанию возвращают указатель, и для получения значения
трубуется разыменовать лик, например `пусть а: &лик Чел = *{"имя" "фамилия" "отчество"}`, и даже
в этом примере строки используются как указатели, а потому разыменовывания не требуют.

Массивы в свою очечредь возвращают массивы, и НЕЯВНО в указатели не переводятся, для этого уже
надо взять адрес с массива обычным для С способом `&[1 2 3]`, что вернет указатель на значение массива,
то есть `пусть ук_ч: *ц64 = &[1 2 3 4 5]`.

`тлен` - это синоним к `ч64`, заменяет `void` в С, является стандартным типом для возвращаемого значения функции.

## Области видимости

Их нет, кроме как между функциями.

## Встроенные типы и примеры

- ч - число
- ц - целое
- в - вещественное

```
мера						sizeof
ч8							int8, byte
ч16							int16
ч32							int32
ч64							int64
ц8							uint8
ц16							uint16
ц32							uint32
ц64							uint64
в32							float, single
в64							double, real
тлен						void
*							*
*тлен						void *
стр *ц8						unsigned char *
**ч32						int **
лик _						struct _ *
лик Чето					struct Some *
&лик _						struct _
&лик Чето					struct Some
счет						enum
счет Чето					enum Some
[ч32]						int[]
[[ц64]]						uint64[][]
[ч32 123]					int[123]
[[ц64 3] 4]					uint64[4][3]
(ч32 ч32 ! ч32) 			int(*f)(int, int) ; это в любом случае указатель
[(ч32 ч32 ! ч32) 2] 		int (*op[2])(int, int)
(тлен)						void(*f)()
```

## Знаки

```
+			+
-			-
*			*
/			/
* 			*
& 			&
()			()
->			->
-@			.
[]			[]
/:			div в паскале
```

# Препроцессор

В С знак `#` является чуть ли не частью данных инструкций, в данном же языке # это отдельный токен
и например `#    вот` будет правильно.

Для обоначения работы с токенами будет использоваться два типа токенов:
- текстовый - такой токен как он виден в изначельном тексте
- примененный - токен который уже прошел обработку препроцессором, то есть он не обязан быть равен своему
текстовому типу, так как например может быть заменен макросом например или чем еще.

## вот
```
#вот имя литерал
```
`вот` - сокращенная версия для `#define`, для простых случаев заменой в 1 токен.

И имя и литерал текстовые токены.

## склеивание

Как и в С склеивание происходит через символы, но не через `##`, а через `#+`.

Оба склеиваемых токена примененные.

## превращение в строку

Символы `#"` `"#` облагают токены которые будут превражены в строки, а между токенами будет вставлены пробелы.

В строки превращаются токены текстовые.

## се
```
#се (#
	выражение или чето еще и тут тоже многострочно
#)
#се макро(а б н) (#
	тут типа подмен#+а токено#+в и склеива#+н#+ие тоже
	многострочное и никаких / как в С
#)
```
`#се` - это `#define` для макро и для многословных подстановок, скобки `(#` `#)` используются
чтобы не исползовать `\` для перевода и сами являются отдельным видом токена.

Все токены в теле макроса текстовые, как и его имя и аргументы, и подменяются вместо вызова макроса
и уже потом обрабатываются препроцессором.

## буки
Куда интереснее чем просто `#define`, а сама идея взята из концепции
Literate programming, например:
```
#се выход(код_выхода) (#
_асм "
    быть еах 60
    быть еди "+код_выхода+"
    сзов
"
#)
#буки (# выйти с кодом #код_выхода# #) (# выход(код_выхода) #)

;; вызов ;;
выйти с кодом 123,
```

То есть от обычного `#define` вызов которого сделан по подобию функции, здесь вызов
происходит целой структурой похожей на предложение в неком языке. Все аргументы в теле
вызова облагаются символами `#` с друх сторон и при этом два аргумента должны
разделяться хотя бы одним словом.
Ещё пример:

```
#вот размер_асма 17
#се бук(буки) (#
    ( размера ( *#"буки"# ) > 127 ? размер_асма : размер_асма - 2)
#)
#се ведать(буки) (# _асм "
    быть еах _ЗДЕСЬ
    быть еси еах
    плюс еси " + бук буки, + "
    плюс еах " + ( бук буки, + размера ( *#"буки"# )) + "
    идти рах
; здесь должно быть еах
пусть байт \"" + #"буки"# + "\" 10
    быть еах 1
    быть еди 1
    быть едх чбайт " + размера ( *#"буки"# ) + "
    сзов
"
#)
#буки (# целых 0 раз#|раза ведать #слова# . #) (##)
#буки (#
    целых #раз# раз#|раза ведать #слова# .
#) (#
_асм "
    быть ебх "+ раз +"
    быть ебп _ЗДЕСЬ
"
    ведать слова,
_асм "
    --ебх
    ид0 2
    идти рбп
"
#)

;; вызов ;;
целых 10 раз ведать эээ world .
целых 2 раза ведать ЭЭЭ world .
```

Здесь уже используются `#|`, которые позволяют делать разные слова в
предложении при вызове, удобно использовать для написания предложений
на синтетических языках.

Если предложение не оканчивается на некий токен в своем теле,
 то послежний аргумент надо закрывать используя запятую.

## include

Или же в данном языке `#влечь`.
```
#влечь "ввывд.ср"
#влечь (
	"один_файл.ср"
	"два_файл.ср"
	"три_файл.ср"
	"и_так_далее_файл.ср"
)
```

## TODO: тут надо сделать еще условия для флагов из компилятора, например для выбора кода для ОС

# Ключевые слова

## Счет(enum)

```
счет ЧЕТО(
	А ; 1
	Б ; 2
	В
	Г
	Д 7 ; 7
	Ж ; 5
	З ; 6
)
ЧЕТО.А
ЧЕТО.Б
ЧЕТО.З
```

## Лик(struct)

```
лик Чето(
	а : ч32
	йцук/б : ц64
)
```

## break continue

отсутствуют

## label, goto или метка, идти

```
asdf:
goto adsf;

йцук:
идти йцук

Используются вместо break и continue, так как они считаются избыточными
и усложнающими реализацию циклов для компилятора.
На них также распространяются области видимостей функций, в ассемблере к каждой
метке добавляется сигнатура функции.
;;
	может быть сделать глобальные метки, чтобы а вот чебы нет
;;
```

## Циклы

```
while(1) { ... }
вечно ( ... ) ; в ассемблере оно вообще освобождено от проверки в данном случае

while(expr) { ... }
пока выражение ( ... )

for (с = 0; с < 10; с++) { ... }
для с на 0..10 <шаг 1> ( ... )
for (с = 0; с <= 10; с++) { ... }
для с на 0..=10 <шаг 1> ( ... )
for (с = 10; с >= 0; с--) { ... }
для с на 10..=0 <шаг -1> ( ... )

for (set; expr; change) { ... }
цикл set, expr, change ( ... )
```

## if else

```
если выражение (
) иначели выражение (
) иначели выражение (
) иначели выражение (
) иначе (
)
```

## Тернарный if else

```
x == 10 ?? (
	a = 10
	b = 12
) :? x == 11 ?? (
	a = 12
	b = 10
) :: (
	a = (b = 11),
)
```
После `??` и `::` идут всегда скобки блоков, что значит внутри них, могут быть
не только выражения.

Такой тернарный if else также не является выражением.

## switch хотя скорее match

потом короче придумаю но будет отличаться от C

## Глобальные переменные

```
пусть переменная = глобальное_выражение
```

## Функции
Функция объявляется со слова "фц" и последующим именем функции
дальше идут аргумента, после вохвращаемый тип, или если его нет, то по умолчанию
он будет `тлен`, после идут скобки блока с телом функции.
```
фц имя (арг арг ... арг) выр_типа (
	...
)

фц глав (арги:стр аргов:ч32) тлен ()
фц глав (арги:стр аргов:ч32) ()
```

# Выражения
В основном как в C, будут перечислены лишь основные отличия.

## Связка выражений(tuple) и pipeline оператор
В C несколко выражений могут быть перечислены через запятую, вместо `;`,
при этом если такое выражение используется для вычисления, то все выражения,
перечисленные перечисленные таким образом через запятую, кроме последнего,
будут просто вычислены, а последнее также вычислено, но также возвращено, как
результат такого перечисления.

В данном же языке, запятые использыются для разделения выражений, а `;` для
комментариев, поэтому для подобных махинаций используются связки выражений
(кортеж - не интуитивное слово для данной концепции), перечисленные в скобках
выражения через запятую. Если в скобках просто выражение, то связкой оно
являться не будет, но если перед закрывающей скобкой будет запятая, то вот уже да.

Piepline оператор - `|>`, как в F# или OCaml. Испольуется для передачи
выражения слева от него в выражение функции справа от него. Если выражением
слева от него является связка выражений, то каждое выражение связки
будет передано, как аргумент в выражение функции.

Связка выражений может содержать любое `>= 0` количество выражений внутри себя,
например:
```
фц фа (а: ч32) ()
фц фб (а б: ч32) ()
фц фв () ()

1 |> фа
(1,) |> фа
(1, 2) |> фб
() |> фв

пусть (а б в: ч32)
а = (б = 10, в = 11, 12)
```

## "СВО(Subject, Verb, Object) точка" как в ООП, но без ООП
В ООП у экземпляра некого класса можно вызвать метод данного класса, и передать
данный экземпляр внутрь метода(в основном двумя способами: либо по подобию как в например C#,
в качестве контекста, к которому можно обратиться через слово `this`; либо как в например питоне,
в качестве просто первого аргумента метода, часто называемого `self`), что достаточно удобно.

Данный же язык ООП парадигму не проповедает, тем не менее "СВО точка" работает по подобию
вызова методов питона, передавая любое выражение в качестве первого аргумента любой функции
используемой вместо метода.
```
фц плюс (а б: ч32) ч32 (воздать а + б)

пусть (а б в: ч32)
в = а.плюс(б)
в = 10.плюс(20)

фц освободить_регистры(п: лик Проц) ( ... )

путсь (процессор: лик Проц)
процессор.освободить_регистры(),
```

## Многочисленный вызов как замена varargs
varargs - уродство в ассемблере при вызове функции, и в данном языке оно отсутствует,
тем не менее нужда в вызове некоторой функции с разным количеством аргументов(например `printf`)
никуда не девается. Вместо этого в языке, в котором поддерживается перегрузка функций,
можно просто одну и ту же функцию вызывать несколько раз подряд, но это становится
уродством уже не в ассемблере, а в самом языке.
```
фц вещать (ч: ч64) (...)
фц вещать (с: стр) (...)
фц вещать (с: в64) (...)

вещать..(123 "текст текст" 123.312 "эээ"),

фц ф(а: ч32) ч32 ( воздать а + 10 )
фц ф(а б: ч32) ч32 ( воздать а + б )

пусть (а: ч32)
а = ф..(123, (10, 11), 321),
```
`..`(две точки) - оператор многочисленного вызова функции. По сути лишь синтаксический сахар
множественного вызова одной и той же функции. Если при таком вызове, в качестве аргумента
будет передана связка выражений, то она будет применена к вызову функции,
как при использовании связки с `|>` оператором. Результатом же такого вызова будет возвращенное
значение последнего вызова из всех.

# Ассемблер
```
пусть ( а: ч32 )
_асм "
	быть еах 123
	плюс (рбп а), еах
	минс (рбп а) " + 123 + "
"
```

