# Язык с минимальным неявным использованием стэка

Правила:
- Стэк используется ТОЛЬКО для стэк фрэйма и хранения на нем локальных переменных функций, а также
для сохранения регистров `рбх` и `р12`.
- Регистры `рбх` и `р12` неизменяемы между вызовами функций и используются для сохранения промежуточных
значений в них между вызовами функций, если это требуется.
- Функция может иметь максимум 7 аргументов, все передаются через регистры.
- Выражения(Expression) ограничены в сложности и длине, так как слишком сложные выражения используют стэк
для сохранения промежуточных вычислений, того же самого можно достичь за счет сохранения
промежуточных вычислений в переменные, которые и так на стэке. Это ограничивает пользователя в сложности
выражений но в тоже время не скрывает от него работу с памятью абсолютно.
- Типизированные регистры доступны в качестве переменных, ради еще большего избежания использования стэка.
- Передача в функции массивов и структур как таковых запрещается, только через указатели.
- Строки и массивы - НЕ УКАЗАТЕЛИ и неявнно не преобразуются, строки - массивы `ц8`,
массивы это по сути просто ассемблерные метки, от которых идут подрят значения,
указатели - сущности, значениями которых и являются эти метки. Значение массива - все его элементы,
значение указателя - просто адрес.

# Переменные, аргументы и поля структур

Переменная - один участок памяти,
к которому может быть прявязано множество имен и которые даже могут иметь разные
типы, но при этом одинаковый размер.

Переменные, аргументы функций и поля структур являются одной и той же сущиностью,
за исключением того, что аргументы функций не используют множество имен и
различные типы для одного участка памяти, так как это влияет на сигнатуру функции.

Далее переменая, аргумнент и поле будут взаимозаменяемыми понятиями и иметь возможный синтаксис:

## Синтаксис аргументов

```
имя : тип
имя/имя : тип
имя/имя : тип, имя/имя : тип
имя имя имя/имя имя: тип
```

Знак "," разделяет участок на разные типы.

Знак "/" разделяет участок по разным именам для одного типа.

Таких разделителей может быть колько угодно. Использование разделителя "/" в аргументах
функций допускается, так как не влияет на сигнатуру функции.

## Про примитивные значения

Обыченое выражение строки, например `"строка"`, возвращает не массив, а указатель, по причине того,
что просто чаще используются строки с указателями, чтобы получить массив со строки, нужно разыменовать ее
обычным для С способом `*"строка"`, и тогда это значение вернет массив `ц8`.

Лики как и строки тоже по укмолчанию возвращают указатель, и для получения значения
трубуется разыменовать лик, например `пусть а: &лик Чел = *{"имя" "фамилия" "отчество"}`, и даже
в этом примере строки используются как указатели, а потому разыменовывания не требуют.

Массивы в свою очечредь возвращают массивы, и НЕЯВНО в указатели не переводятся, для этого уже
надо взять адрес с массива обычным для С способом `&[1 2 3]`, что вернет указатель на значение массива,
то есть `пусть ук_ч: *ц64 = &[1 2 3 4 5]`.

`тлен` - это синоним к `ч64`, заменяет `void` в С, является стандартным типом для возвращаемого значения функции.

## Области видимости

Их нет, кроме как между функциями.

## Calling Convention

При вызове функции 7 значений помещаются в регистры от р8 до р15 исключая р12.

```
;; эти идеи противоречат правилам но вообще может быть потом ;;
; Остальные параметры возможно потом будут на стэке, сейчас это недопустимо?
; Можно ли сделать параметры на 16 байт ниже стэка текущего чтобы они были внутри стэкфрэйма?
; 16 байт где 8 на точку возврата и 8 на старый рбп.
; При выходе из функции функция сама очищает свой стэк.
; Если в будущем для передачи параметров будет использоваться стэк тоже, то стэк занимаемый
; при вызове освобождается самой функцей?
```

## Встроенные типы

- ч - число
- ц - целое
- в - вещественное

```
мера						sizeof
ч8							int8, byte
ч16							int16
ч32							int32
ч64							int64
ц8							uint8
ц16							uint16
ц32							uint32
ц64							uint64
в32							float, single
в64							double, real
тлен						void
*							*
*тлен						void *
стр *ц8						unsigned char *
**ч32						int **
лик _						struct _ *
лик Чето					struct Some *
&лик _						struct _
&лик Чето					struct Some
счет						enum
счет Чето					enum Some
[ч32]						int[]
[[ц64]]						uint64[][]
[ч32 123]					int[123]
[[ц64 3] 4]					uint64[4][3]
(ч32 ч32 ! ч32) 			int(*f)(int, int) ; это в любом случае указатель
[(ч32 ч32 ! ч32) 2] 		int (*op[2])(int, int)
(тлен)						void(*f)()
```

## Знаки

```
+			+
-			-
*			*
/			/
* 			*
& 			&
()			()
->			->
[]			[]
```

# Препроцессор

В С знак `#` является чуть ли не частью данных инструкций, в данном же языке # это отдельный токен
и например `#    вот` будет правильно. Кроме просто использования `#` для определения начала
инструкций но и для например некоторых других символов связанных с препроцессором.

Для обоначения работы с токенами будет использоваться два типа токенов:
- тестовый - такой токен как он виден в изначельном тексте
- примененный - токен который уже прошел обработку препроцессором, то есть он не обязан быть равен своему
текстовому типу, так как например может быть заменен макросом например или чем еще.

## вот
```
#вот имя литерал
```
`вот` - сокращенная версия для `#define`, для простых случаев заменой в 1 токен.

И имя и литерал текстовые токены.

## склеивание

Как и в С склеивание происходит через символы, но не через `##`, а через `#+`.

Оба склеиваемых токена примененные.

## превращение в строку

Символы `#"` `"#` облагают токены которые будут превражены в строки, а между токенами будет вставлены пробелы.

В строки превращаются токены текстовые.

## се
```
#се (#
	выражение или чето еще и тут тоже многострочно
#)
#се макро(а б н) (#
	тут типа подмен#+а токено#+в и склеива#+н#+ие тоже
	многострочное и никаких / как в С
#)
```
`#се` - это `#define` для макро и для многословных подстановок, скобки `(#` `#)` используются
чтобы не исползовать `\` для перевода и сами являются отдельным видом токена.

Все токены в теле макроса текстовые, как и его имя и аргументы, и подменяются вместо вызова макроса
и уже потом обрабатываются препроцессором.

## сказ

TODO: тут надо про него расписать когда будет сделан

## include

Или же в данном языке `#влечь`.
```
#влечь "ввывд.ср"
#влечь (
	"один_файл.ср"
	"два_файл.ср"
	"три_файл.ср"
	"и_так_далее_файл.ср"
)
```

## TODO: тут надо сделать еще условия для флагов из компилятора, например для выбора кода для ОС

# Ключевые слова

## Счет(enum)

```
счет ЧЕТО(
	А ; 1
	Б ; 2
	В
	Г
	Д 7 ; 7
	Ж ; 5
	З ; 6
)
ЧЕТО.А
ЧЕТО.Б
ЧЕТО.З
```

## Лик(struct)

```
лик Чето(
	а : ч32
	йцук/б : ц64
)
```

## break continue

отсутствуют

## label, goto или метка, идти

```
asdf:
goto adsf;

йцук:
идти йцук

Используются вместо break и continue, так как они считаются избыточными
и усложнающими реализацию циклов для компилятора.
На них также распространяются области видимостей функций, в ассемблере к каждой
метке добавляется сигнатура функции.
;;
	может быть сделать глобальные метки, чтобы а вот чебы нет
;;
```

## Циклы

```
while(1) { ... }
вечно ( ... ) ; в ассемблере оно вообще освобождено от проверки в данном случае

while(expr) { ... }
пока выражение ( ... )

for (с = 0; с < 10; с++) { ... }
для с на 0..10 <шаг 1> ( ... )
for (с = 0; с <= 10; с++) { ... }
для с на 0..=10 <шаг 1> ( ... )
for (с = 10; с >= 0; с--) { ... }
для с на 10..=0 <шаг -1> ( ... )

for (set; expr; change) { ... }
цикл set, expr, change ( ... )
```

## if else

```
если выражение (
) иначели выражение (
) иначели выражение (
) иначели выражение (
) иначе (
)
```

## switch хотя скорее match

потом короче придумаю но будет отличаться от C

## Глобальные переменные

```
пусть переменная = глобальное_выражение
```

## Функции

```
;;
	функция объявляется со слова "фц" и последующим именем функции
	дальше идут переменные и их типы точно также как и в блоке "пусть"
	после идут скобки с телом функции
;;
фц имя (арг арг ... арг) выр_типа (
	...
)

фц глав (арги:стр аргов:ч32) (
;;
	каждая функция может иметь объявления перемнных
	они объявляются в блоке пусть, похоже на var в паскале
	но тут меньше символов, также один участок памяти
	может иметь разные имена,
	то есть имен например два, а переменная одна,
	такие имена пишутся через /,
	после перечисления имен через символ : пишется тип переменных

	тип вфункции после первых скобок, если типа нет, то тип становистя тленом
;;
	пусть (
		имя/имя : выр_типа
		имя
		имя
		имя
		:
		 выр_типа
	)
	пусть (
		а/б с д : ч32
		йцук : ч64
		г/д : ц64, е/ж : в64, з : *ч32
;;
	вот здесь переменные объявлены через запятую, но не для разделения объявлений
	а для обозначения того, что они относятся к одному участку памяти, то есть
	не прото "г" и "д" одинаковы и имеют один участок памяти, но и даже "е", "ж" и "з"
	принадлежат к тому же участку памяти, возможно это как минимум потому что они
	одинакового размера: "ц64" и "в64", как и "з" с типом указателя
;;
	)
;;
	переменные могут объявляться только так и
	желательно их объявлять только вначале или почти в начале функции,
	объявление переменных запрещено в блоках 'если' и циклах

	компилятором это не запрещено но будет приводить к лишней трате
	стэка, так как областей видимости, кроме как в функциях в этом
	языке не предусмотрено, и переменные будут переобъявляться на стэк
	каждую иттерацию
;;
)
```

## Присваивание

```
выражение адреса = выражение

пусть ( а : ч32 )
а = 123
```

### Индексы

```
пусть ( а : [ч32] с : ч32 )
а[0] = 123
а[с] = 123
```

## Выражение

### Приведение типа

```
окак тип_вырж вырж
```

## Ассемблер

```
пусть ( а : ч32 )
_асм "
	быть еах 123
	плюс (рбп а), еах
	минс (рбп а) 123
"
```

