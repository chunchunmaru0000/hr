# Язык с минимальным использованием стэка

Правила:
- Стэк используется ТОЛЬКО для стэк фрэйма и хранения на нем локальных переменных функций, а также
для сохранения регистров `рбх` и `р12`.
- Регистры `рбх` и `р12` неизменяемы между вызовами функций и используются для сохранения промежуточных
значений в них между вызовами функций, если это требуется.
- Функция может иметь максимум 7 аргументов, все передаются через регистры.
- Выражения(Expression) ограничены в сложности и длине, так как слишком сложные выражения используют стэк
для сохранения промежуточных вычислений, того же самого можно достичь за счет сохранения
промежуточных вычислений в переменные, которые и так на стэке. Это ограничивает пользователя в сложности
выражений но в тоже время не скрывает от него работу с памятью абсолютно.
- Типизированные регистры доступны в качестве переменных, ради еще большего избежания использования стэка.
- Передача в функции массивов и структур как таковых запрещается, только через указатели.
- Строки и массивы - НЕ УКАЗАТЕЛИ и неявнно не преобразуются, строки - массивы 'ц8',
массивы это по сути просто ассемблерные метки, от которых идут подрят значения,
указатели - сущности, значениями которых и являются эти метки. Значение массива - все его элементы,
значение указателя - просто адрес.

# Переменные, аргументы и поля структур

Переменная - один участок памяти,
к которому может быть прявязано множество имен и которые даже могут иметь разные
типы, но при этом одинаковый размер.

Переменные, аргументы функций и поля структур являются одной и той же сущиностью,
за исключением того, что аргументы функций не используют множество имен и
различные типы для одного участка памяти, так как это влияет на сигнатуру функции.

Далее переменая, аргумнент и поле будут взаимозаменяемыми понятиями и иметь возможный синтаксис:

## Синтаксис аргументов

```
имя : тип
имя/имя : тип
имя/имя : тип, имя/имя : тип
имя имя имя/имя имя: тип
```

Знак "," разделяет участок на разные типы.

Знак "/" разделяет участок по разным именам для одного типа.

Таких разделителей может быть колько угодно. Использование разделителя "/" в аргументах
функций допускается, так как не влияет на сигнатуру функции.

## Области видимости

Их нет, кроме как между функциями.

## Calling Convention

При вызове функции 7 значений помещаются в регистры от р8 до р15 исключая р12.

```
;; эти идеи противоречат правилам но вообще может быть потом ;;
; Остальные параметры возможно потом будут на стэке, сейчас это недопустимо?
; Можно ли сделать параметры на 16 байт ниже стэка текущего чтобы они были внутри стэкфрэйма?
; 16 байт где 8 на точку возврата и 8 на старый рбп.
; При выходе из функции функция сама очищает свой стэк.
; Если в будущем для передачи параметров будет использоваться стэк тоже, то стэк занимаемый
; при вызове освобождается самой функцей?
```

# Ключевые слова

## Влечь

```
влечь "ввывд"
```

## Вот

```
вот имя выражение
вот чето 1 + 3 + 4 + 5
```

## Встроенные типы

ч - число
ц - целое
в - вещественное

```
ч8							int8, byte
ч16							int16
ч32							int32
ч64							int64
ц8							uint8
ц16							uint16
ц32							uint32
ц64							uint64
в32							float, single
в64							double, real
тлен						void
*							*
*тлен						void *
стр *ц8						unsigned char *
**ч32						int **
лик _						struct _ *
лик Чето					struct Some *
&лик _						struct _
&лик Чето					struct Some
счет						enum
счет Чето					enum Some
[ч32]						int[]
[[ц64]]						uint64[][]
[ч32 123]					int[123]
[[ц64 3] 4]					uint64[4][3]
(ч32 ч32 ! ч32) 			int(*f)(int, int) ; это в любом случае указатель
[(ч32 ч32 ! ч32) 2] 		int (*op[2])(int, int)
(тлен)						void(*f)()
```

## Знаки

```
+			+
-			-
*			*
/			/
* 			*
& 			&
()			()
->			->
[]			[]
```

## Счет(enum)

```
счет ЧЕТО(
	А ; 1
	Б ; 2
	В
	Г
	Д 7 ; 7
	Ж ; 5
	З ; 6
)
ЧЕТО.А
ЧЕТО.Б
ЧЕТО.З
```

## Лик(struct)

```
лик Чето(
	а : ч32
	йцук/б : ц64
)
```

## break continue

отсутствуют

## label, goto или метка, идти

```
asdf:
goto adsf;

йцук:
идти йцук

Используются вместо break и continue, так как они считаются избыточными
и усложнающими реализацию циклов для компилятора.
На них также распространяются области видимостей функций, в ассемблере к каждой
метке добавляется сигнатура функции.
;;
	может быть сделать глобальные метки, чтобы а вот чебы нет
;;
```

## Циклы

```
while(1) { ... }
вечно ( ... ) ; в ассемблере оно вообще освобождено от проверки в данном случае

while(expr) { ... }
пока выражение ( ... )

for (с = 0; с < 10; с++) { ... }
для с на 0..10 <шаг 1> ( ... )
for (с = 0; с <= 10; с++) { ... }
для с на 0..=10 <шаг 1> ( ... )
for (с = 10; с >= 0; с--) { ... }
для с на 10..=0 <шаг -1> ( ... )

for (set; expr; change) { ... }
цикл set, expr, change ( ... )
```

## if else

```
если выражение (
) иначели выражение (
) иначели выражение (
) иначели выражение (
) иначе (
)
```

## switch хотя скорее match

потом короче придумаю но будет отличаться от C

## Глобальные переменные

```
пусть переменная = глобальное_выражение
```

## Функции

```
;;
	функция объявляется со слова "фц" и последующим именем функции
	дальше идут переменные и их типы точно также как и в блоке "пусть"
	после идут скобки с телом функции
;;
фц имя (арг арг ... арг) выр_типа (
	...
)

фц глав (арги:стр аргов:ч32) (
;;
	каждая функция может иметь объявления перемнных
	они объявляются в блоке пусть, похоже на var в паскале
	но тут меньше символов, также один участок памяти
	может иметь разные имена,
	то есть имен например два, а переменная одна,
	такие имена пишутся через /,
	после перечисления имен через символ : пишется тип переменных

	тип вфункции после первых скобок, если типа нет, то тип становистя тленом
;;
	пусть (
		имя/имя : выр_типа
		имя
		имя
		имя
		:
		 выр_типа
	)
	пусть (
		а/б с д : ч32
		йцук : ч64
		г/д : ц64, е/ж : в64, з : *ч32
;;
	вот здесь переменные объявлены через запятую, но не для разделения объявлений
	а для обозначения того, что они относятся к одному участку памяти, то есть
	не прото "г" и "д" одинаковы и имеют один участок памяти, но и даже "е", "ж" и "з"
	принадлежат к тому же участку памяти, возможно это как минимум потому что они
	одинакового размера: "ц64" и "в64", как и "з" с типом указателя
;;
	)
;;
	переменные могут объявляться только так и
	желательно их объявлять только вначале или почти в начале функции,
	объявление переменных запрещено в блоках 'если' и циклах

	компилятором это не запрещено но будет приводить к лишней трате
	стэка, так как областей видимости, кроме как в функциях в этом
	языке не предусмотрено, и переменные будут переобъявляться на стэк
	каждую иттерацию
;;
)
```

## Присваивание

```
выражение адреса = выражение

пусть ( а : ч32 )
а = 123
```

### Индексы

```
пусть ( а : [ч32] с : ч32 )
а[0] = 123
а[с] = 123
```

## Выражение

### Приведение типа

```
окак тип_вырж вырж
```

## Ассемблер

```
пусть ( а : ч32 )
_асм "
	быть еах 123
	плюс (рбп а), еах
	минс (рбп а) 123
"
```

